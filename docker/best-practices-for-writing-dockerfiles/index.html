<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Micronaut,Groovy,Gradle,Java,文档,中文">
    <meta name="description" content="Micronaut Groovy Gradle Java 文档 中文">
    <meta name="author" content="林威羽">
    
    <title>
        
            Best practices for writing Dockerfiles |
        
        林威羽的笔记
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"rgb(153,153,0)","avatar":"/images/avatar.jpg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"400px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":null,"description":"def contains🚀 = ['Micronaut', 'Groovy', 'Gradle', 'etc']"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                林威羽的笔记
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

    <a target="_blank" rel="noopener" href="https://github.com/linweiyu21/" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80"
        viewBox="0 0 250 250" style="fill:#64CEAA; color:#fff; position: absolute; top: 0; border: 0; right: 0;"
        aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor" class="octo-body"></path>
      </svg></a>
    <style>
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out
      }

      @keyframes octocat-wave {

        0%,
        100% {
          transform: rotate(0)
        }

        20%,
        60% {
          transform: rotate(-25deg)
        }

        40%,
        80% {
          transform: rotate(10deg)
        }
      }

      @media (max-width:500px) {
        .github-corner:hover .octo-arm {
          animation: none
        }

        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out
        }
      }
    </style>
</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Best practices for writing Dockerfiles</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">林威羽</span>
                        
                            <span class="author-label">Lv8</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-23 09:58:35</span>
        <span class="mobile">2022-05-23 09:58</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Docker/">Docker</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Docker/">Docker</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Notes/">Notes</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <!-- TOC -->

<ul>
<li><a href="#general-guidelines-and-recommendations-%E4%B8%80%E8%88%AC%E5%87%86%E5%88%99%E5%92%8C%E5%BB%BA%E8%AE%AE">General guidelines and recommendations (一般准则和建议)</a><ul>
<li><a href="#create-ephemeral-containers-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E5%AE%B9%E5%99%A8">Create ephemeral containers (创建临时容器)</a></li>
<li><a href="#understand-build-context-%E7%90%86%E8%A7%A3%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87">Understand build context (理解构建上下文)</a></li>
<li><a href="#pipe-dockerfile-through-stdin-%E9%80%9A%E8%BF%87-stdin-%E7%AE%A1%E9%81%93%E5%8C%96-dockerfile">Pipe Dockerfile through <code>stdin</code> (通过 <code>stdin</code> 管道化 Dockerfile)</a><ul>
<li><a href="#build-an-image-using-a-dockerfile-from-stdin-without-sending-build-context-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-%E4%B8%8D%E5%8F%91%E9%80%81%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87">Build an image using a Dockerfile from stdin, without sending build context (使用来自 stdin 的 Dockerfile 构建镜像, 不发送构建上下文)</a></li>
<li><a href="#build-from-a-local-build-context-using-a-dockerfile-from-stdin-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-dockerfile">Build from a local build context, using a Dockerfile from stdin (从本地构建上下文进行构建, 使用来自 stdin 的 Dockerfile)</a></li>
<li><a href="#build-from-a-remote-build-context-using-a-dockerfile-from-stdin-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-dockerfile-%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA">Build from a remote build context, using a Dockerfile from stdin (使用来自 stdin 的 Dockerfile, 从一个远程构建上下文进行构建)</a></li>
</ul>
</li>
<li><a href="#exclude-with-dockerignore-%E4%BD%BF%E7%94%A8-dockerignore-%E8%BF%9B%E8%A1%8C%E6%8E%92%E9%99%A4">Exclude with .dockerignore (使用 .dockerignore 进行排除)</a></li>
<li><a href="#use-multi-stage-builds-%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA">Use multi-stage builds (使用多阶段构建)</a></li>
<li><a href="#dont-install-unnecessary-packages-%E4%B8%8D%E8%A6%81%E5%AE%89%E8%A3%85%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85">Don’t install unnecessary packages (不要安装不必要的包)</a></li>
<li><a href="#decouple-applications-%E8%A7%A3%E8%80%A6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">Decouple applications (解耦应用程序)</a></li>
<li><a href="#minimize-the-number-of-layers-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%B1%82%E7%9A%84%E6%95%B0%E9%87%8F">Minimize the number of layers (最小化层的数量)</a></li>
<li><a href="#sort-multi-line-arguments-%E6%8E%92%E5%BA%8F%E5%A4%9A%E8%A1%8C%E5%8F%82%E6%95%B0">Sort multi-line arguments (排序多行参数)</a></li>
<li><a href="#leverage-build-cache-%E5%88%A9%E7%94%A8%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98">Leverage build cache (利用构建缓存)</a></li>
</ul>
</li>
<li><a href="#dockerfile-instructions-dockerfile-%E6%8C%87%E4%BB%A4">Dockerfile instructions (Dockerfile 指令)</a><ul>
<li><a href="#from-from-%E6%8C%87%E4%BB%A4">FROM (FROM 指令)</a></li>
<li><a href="#label-label-%E6%8C%87%E4%BB%A4">LABEL (LABEL 指令)</a></li>
<li><a href="#run-run-%E6%8C%87%E4%BB%A4">RUN (RUN 指令)</a><ul>
<li><a href="#apt-get">apt-get</a></li>
<li><a href="#using-pipes-%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93">Using pipes (使用管道)</a></li>
</ul>
</li>
<li><a href="#cmd-cmd-%E6%8C%87%E4%BB%A4">CMD (CMD 指令)</a></li>
<li><a href="#expose-expose-%E6%8C%87%E4%BB%A4">EXPOSE (EXPOSE 指令)</a></li>
<li><a href="#env-env-%E6%8C%87%E4%BB%A4">ENV (ENV 指令)</a></li>
<li><a href="#add-or-copy-add-%E6%88%96-copy-%E6%8C%87%E4%BB%A4">ADD or COPY (ADD 或 COPY 指令)</a></li>
<li><a href="#entrypoint-entrypoint-%E6%8C%87%E4%BB%A4">ENTRYPOINT (ENTRYPOINT 指令)</a></li>
<li><a href="#volume-volume-%E6%8C%87%E4%BB%A4">VOLUME (VOLUME 指令)</a></li>
<li><a href="#user-user-%E6%8C%87%E4%BB%A4">USER (USER 指令)</a></li>
<li><a href="#workdir-workdir-%E6%8C%87%E4%BB%A4">WORKDIR (WORKDIR 指令)</a></li>
<li><a href="#onbuild-onbuild-%E6%8C%87%E4%BB%A4">ONBUILD (ONBUILD 指令)</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<!-- /TOC -->

<p>当运行一个镜像并生成一个容器时, 添加了一个新的可写 (writable) 层 (容器层 (container layer)) 到下面的层的最上面</p>
<p>所有对于运行中容器的修改, 例如写入新文件, 修改已存在的文件, 删除文件, 都是写入到这个容器层</p>
<h2 id="General-guidelines-and-recommendations-一般准则和建议"><a href="#General-guidelines-and-recommendations-一般准则和建议" class="headerlink" title="General guidelines and recommendations (一般准则和建议)"></a>General guidelines and recommendations (一般准则和建议)</h2><h3 id="Create-ephemeral-containers-创建临时容器"><a href="#Create-ephemeral-containers-创建临时容器" class="headerlink" title="Create ephemeral containers (创建临时容器)"></a>Create ephemeral containers (创建临时容器)</h3><p>尽量创建 “短暂的&#96; 容器</p>
<p>“短暂的” 意味着无状态的, 可以随时停止, 启动和重启的容器</p>
<p>尽量创建轻量级, 无依赖或最小依赖的容器</p>
<h3 id="Understand-build-context-理解构建上下文"><a href="#Understand-build-context-理解构建上下文" class="headerlink" title="Understand build context (理解构建上下文)"></a>Understand build context (理解构建上下文)</h3><p>默认情况下, 以执行 <code>docker build</code> 命令的当前工作目录作为<strong>构建上下文</strong>, 并使用当前工作目录中的 <code>Dockerfile</code></p>
<p>可以使用 <code>-f</code> 标志来指定 <code>Dockerfile</code> 的位置. 就算指定了 <code>-f</code> 标志, 默认情况下还是将当前工作目录中的文件目录及其递归文件目录发送给 Docker daemon 作为构建上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./myproject</span><br><span class="line">├── context</span><br><span class="line">│   └── hello</span><br><span class="line">└── dockerfiles</span><br><span class="line">    └── Dockerfile</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t helloapp:v2 -f dockerfiles/Dockerfile context</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-f dockerfiles/Dockerfile</code> - 指定了 <code>Dockerfile</code> 文件的位置</li>
<li><code>context</code> - 指定了构建上下文 (build context)</li>
</ul>
<h3 id="Pipe-Dockerfile-through-stdin-通过-stdin-管道化-Dockerfile"><a href="#Pipe-Dockerfile-through-stdin-通过-stdin-管道化-Dockerfile" class="headerlink" title="Pipe Dockerfile through stdin (通过 stdin 管道化 Dockerfile)"></a>Pipe Dockerfile through <code>stdin</code> (通过 <code>stdin</code> 管道化 Dockerfile)</h3><p>可以通过 <code>stdin</code> 来传递 <code>Dockerfile</code> 给 <code>docker build</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;FROM busybox\nRUN echo &quot;hello world&quot;&#x27;</span> | docker build -</span><br></pre></td></tr></table></figure>

<p><code>echo -e</code> 启用反斜杠转义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">FROM busybox</span></span><br><span class="line"><span class="string">RUN echo &quot;hello world&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="Build-an-image-using-a-Dockerfile-from-stdin-without-sending-build-context-使用来自-stdin-的-Dockerfile-构建镜像-不发送构建上下文"><a href="#Build-an-image-using-a-Dockerfile-from-stdin-without-sending-build-context-使用来自-stdin-的-Dockerfile-构建镜像-不发送构建上下文" class="headerlink" title="Build an image using a Dockerfile from stdin, without sending build context (使用来自 stdin 的 Dockerfile 构建镜像, 不发送构建上下文)"></a>Build an image using a Dockerfile from stdin, without sending build context (使用来自 stdin 的 Dockerfile 构建镜像, 不发送构建上下文)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] -</span><br></pre></td></tr></table></figure>

<p>这个语法使用来自 <code>stdin</code> 的 <code>Dockerfile</code> 构建镜像, 不发送额外的文件作为构建上下文</p>
<p><code>-</code> 代替了 <code>PATH</code> 的位置, 并指示 Docker 从 <code>stdin</code> (只包含一个 <code>Dockerfile</code>) 而不是从一个目录中读取构建上下文</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:latest -&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">FROM busybox</span></span><br><span class="line"><span class="string">RUN echo &quot;hello world&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>上面的例子使用通过 <code>stdin</code> 传递的 <code>Dockerfile</code> 构建镜像. 没有文件作为构建上下文发送给 daemon</p>
<p>在你的 <code>Dockerfile</code> 不需要复制文件到镜像中时去掉构建上下文非常有用, 这样可以提高构建速度, 因为没有文件需要发送给 daemon</p>
<p>如果以 <code>stdin</code> 传递 <code>Dockerfile</code> 但又使用了 <code>COPY</code>&#x2F;<code>ADD</code> 指令, 构建将会报错</p>
<h4 id="Build-from-a-local-build-context-using-a-Dockerfile-from-stdin-从本地构建上下文进行构建-使用来自-stdin-的-Dockerfile"><a href="#Build-from-a-local-build-context-using-a-Dockerfile-from-stdin-从本地构建上下文进行构建-使用来自-stdin-的-Dockerfile" class="headerlink" title="Build from a local build context, using a Dockerfile from stdin (从本地构建上下文进行构建, 使用来自 stdin 的 Dockerfile)"></a>Build from a local build context, using a Dockerfile from stdin (从本地构建上下文进行构建, 使用来自 stdin 的 Dockerfile)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] -f- PATH</span><br></pre></td></tr></table></figure>

<p>这个语法使用你本地文件系统上的文件来构建镜像, 当使用来自 <code>stdin</code> 的 <code>Dockerfile</code></p>
<p>这个语法使用 <code>-f</code> (或 <code>--file</code>) 选项来指定使用哪个 <code>Dockerfile</code>, 使用 <code>-</code> 作为文件名来指示 Docker 从 <code>stdin</code> 中读取 <code>Dockerfile</code></p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build an image using the current directory as context, and a Dockerfile passed through stdin</span></span><br><span class="line">docker build -t myimage:latest -f- . &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">FROM busybox</span></span><br><span class="line"><span class="string">COPY somefile.txt ./</span></span><br><span class="line"><span class="string">RUN cat /somefile.txt</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>使用当前目录作为上下文构建镜像, 并从 <code>stdin</code> 传递 <code>Dockerfile</code></p>
<h4 id="Build-from-a-remote-build-context-using-a-Dockerfile-from-stdin-使用来自-stdin-的-Dockerfile-从一个远程构建上下文进行构建"><a href="#Build-from-a-remote-build-context-using-a-Dockerfile-from-stdin-使用来自-stdin-的-Dockerfile-从一个远程构建上下文进行构建" class="headerlink" title="Build from a remote build context, using a Dockerfile from stdin (使用来自 stdin 的 Dockerfile, 从一个远程构建上下文进行构建)"></a>Build from a remote build context, using a Dockerfile from stdin (使用来自 stdin 的 Dockerfile, 从一个远程构建上下文进行构建)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [OPTIONS] -f- PATH</span><br></pre></td></tr></table></figure>

<p>这个语法使用远程 <code>Git</code> 仓库中的文件构建镜像, 读取来自 <code>stdin</code> 的 <code>Dockerfile</code></p>
<p>这个语法使用 <code>-f</code> (或 <code>--file</code>) 选项来指定使用哪个 <code>Dockerfile</code>, 使用 <code>-</code> 作为文件名来指示 Docker 从 <code>stdin</code> 中读取 <code>Dockerfile</code></p>
<p>这个语法在你从一个没有 <code>Dockerfile</code> 的仓库中进行构建时很有用, 或者你想要使用自定义的 <code>Dockerfile</code> 进行构建而不需要维护这个仓库的分支</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myimage:latest -f- https://github.com/docker-library/hello-world.git &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">FROM busybox</span></span><br><span class="line"><span class="string">COPY hello.c ./</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<p>上述例子使用来自 <code>stdin</code> 的 <code>Dockerfile</code>, 添加来自 “hello-world”  Git 仓库中的 <code>hello.c</code> 文件到镜像中</p>
<p>在背后: 当使用一个远程 Git 仓库作为上下文进行镜像构建时, Docker 在本地机器上执行这个仓库的 <code>git clone</code> 命令, 并将这些文件作为构建上下文发送给 daemon. 所以这个功能要求 <code>git</code> 要安装在你运行 <code>docker build</code> 命令的主机上</p>
<h3 id="Exclude-with-dockerignore-使用-dockerignore-进行排除"><a href="#Exclude-with-dockerignore-使用-dockerignore-进行排除" class="headerlink" title="Exclude with .dockerignore (使用 .dockerignore 进行排除)"></a>Exclude with .dockerignore (使用 .dockerignore 进行排除)</h3><p>使用 <code>.dockerignore</code> 文件来排除掉不是关联到构建中的文件</p>
<h3 id="Use-multi-stage-builds-使用多阶段构建"><a href="#Use-multi-stage-builds-使用多阶段构建" class="headerlink" title="Use multi-stage builds (使用多阶段构建)"></a>Use multi-stage builds (使用多阶段构建)</h3><p><a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/multistage-build/" >多阶段构建<i class="fas fa-external-link-alt"></i></a> 剧烈地减少最终镜像的大小而不用挣扎于减少中间层和文件数量</p>
<p>因为镜像在构建进程的最终阶段被构建, 所以可以通过利用构建缓存来最小化镜像层</p>
<p>如果你的构建包含多层, 可以将它们以 最少修改(确保重用了缓存) 到 最常修改 的顺序进行排序:</p>
<ul>
<li>安装构建应用程序需要的工具</li>
<li>安装或更新库依赖</li>
<li>生成你的应用程序</li>
</ul>
<p>Example - 一个 Go 应用程序的 Dockerfile:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-alpine AS build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为项目安装需要的工具</span></span><br><span class="line"><span class="comment"># 运行 `docker build --no-cache .` 来更新依赖</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache git</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get github.com/golang/dep/cmd/dep</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Gopkg.toml 和 Gopkg.lock 列出项目依赖</span></span><br><span class="line"><span class="comment"># 这些层只有在 Gopkg 文件更新时才重新构建</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Gopkg.lock Gopkg.toml /go/src/project/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/project/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> dep ensure -vendor-only</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制整个项目并构建</span></span><br><span class="line"><span class="comment"># 项目目录中的文件改变时会重新构建这个层</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./go/src/project/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go build -o /bin/project</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这会生成一个单层的镜像</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /bin/project /bin/project</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/project&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="Don’t-install-unnecessary-packages-不要安装不必要的包"><a href="#Don’t-install-unnecessary-packages-不要安装不必要的包" class="headerlink" title="Don’t install unnecessary packages (不要安装不必要的包)"></a>Don’t install unnecessary packages (不要安装不必要的包)</h3><p>为了减小复杂度, 依赖, 文件大小和构建时间, 避免安装额外或不必要的包</p>
<h3 id="Decouple-applications-解耦应用程序"><a href="#Decouple-applications-解耦应用程序" class="headerlink" title="Decouple applications (解耦应用程序)"></a>Decouple applications (解耦应用程序)</h3><p>每个应用程序应该只有一个关注点</p>
<p>解耦应用程序为多个容器使得横向扩展与重用容器更加容易</p>
<p>例如, 一个 web 应用程序栈可能包含三个分开的容器, 每个容器都有自己唯一的镜像, 以解耦的方式来管理 web 应用程序, 数据库和一个基于内存的缓存</p>
<p>将每个容器限制为一个进程是一个很好的经验法则, 但这并不是硬性规定. 例如, 不止容器可以通过 init 进程来生成, 一些程序本身也会生成进程. 例如, Celery 可以产生多个工作进程, 而 Apache 可以为每个请求创建一个进程</p>
<p>使用你最好的判断力来保持容器尽可能干净和模块化</p>
<p>如果容器彼此依赖, 你可以使用 <a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/network/" >Docker 容器网络<i class="fas fa-external-link-alt"></i></a> 来确保这些容器之间可以通信</p>
<h3 id="Minimize-the-number-of-layers-最小化层的数量"><a href="#Minimize-the-number-of-layers-最小化层的数量" class="headerlink" title="Minimize the number of layers (最小化层的数量)"></a>Minimize the number of layers (最小化层的数量)</h3><p>只有 <code>RUN</code>, <code>COPY</code>, <code>ADD</code> 指令会创建层. 其他指令创建临时中间镜像, 不会增加构建的大小</p>
<p>当可能的时候, 使用 <a href="">多阶段构建</a>, 并且只复制你需要的构件到最终镜像中. 这使得你将工具和调试信息包含到中间构建阶段而不会增加最终镜像的大小</p>
<h3 id="Sort-multi-line-arguments-排序多行参数"><a href="#Sort-multi-line-arguments-排序多行参数" class="headerlink" title="Sort multi-line arguments (排序多行参数)"></a>Sort multi-line arguments (排序多行参数)</h3><p>只要有可能, 通过按字母数字排序多行参数来简化以后的更改. 这有助于避免包的重复并不使列表更新更容易. 这也有助于 PR 进行阅读和审查. 在 <code>\</code> 添加一个空格也会有帮助</p>
<p>Example:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">  bzr \</span></span><br><span class="line"><span class="language-bash">  cvs \</span></span><br><span class="line"><span class="language-bash">  git \</span></span><br><span class="line"><span class="language-bash">  mercurial \</span></span><br><span class="line"><span class="language-bash">  subversion \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<h3 id="Leverage-build-cache-利用构建缓存"><a href="#Leverage-build-cache-利用构建缓存" class="headerlink" title="Leverage build cache (利用构建缓存)"></a>Leverage build cache (利用构建缓存)</h3><p>在 <code>docker build</code> 命令上使用 <code>--no-cache=true</code> 选项来关闭缓存</p>
<p>使用如下规则来判断是否使用缓存:</p>
<ul>
<li>从已经存在于缓存中的父镜像开始, 将下一条指令与从该基础镜像派生的所有子镜像进行比较, 以查看其中一个是否使用相同的指令构建的. 如果不是, 则缓存无效</li>
<li>在大多数情况下, 只需将 Dockerfile 中的指令与其中一个子镜像进行比较就足够了. 但是, 某些指令需要更多的检查和解释</li>
<li>对于 <code>ADD</code> 和 <code>COPY</code> 指令, 检查镜像中的文件的内容并为每个文件计算校验和. 这些校验和中不考虑文件的最后修改和最后范围时间. 在查找缓存期间, 将检验和与现有镜像中的校验和进行比较. 如果文件中有任何更改, 例如内容和元数据, 则缓存无效</li>
<li>除了 <code>ADD</code> 和 <code>COPY</code> 指令之外, 缓存检查不会查看容器中的文件来确定缓存匹配. 例如, 在处理 <code>RUN apt-get -y update</code> 命令时, 不会检查容器中更新的文件以确定是否存在缓存命中. 在这种情况下, 只有命令字符串本身用于查找匹配项</li>
</ul>
<p>一旦缓存失效, 所有后续的 <code>Dockerfile</code> 命令都会生成新的镜像并且不会使用缓存</p>
<h2 id="Dockerfile-instructions-Dockerfile-指令"><a href="#Dockerfile-instructions-Dockerfile-指令" class="headerlink" title="Dockerfile instructions (Dockerfile 指令)"></a>Dockerfile instructions (Dockerfile 指令)</h2><h3 id="FROM-FROM-指令"><a href="#FROM-FROM-指令" class="headerlink" title="FROM (FROM 指令)"></a>FROM (FROM 指令)</h3><p>尽量使用最新的官方镜像作为你的镜像的基础镜像</p>
<p>推荐使用 <a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/_/alpine/" >Alpine<i class="fas fa-external-link-alt"></i></a> 镜像, 因为它受到严格控制且体积非常小 (当前小于 6 MB), 同时仍然是一个完整的 Linux 发行版</p>
<h3 id="LABEL-LABEL-指令"><a href="#LABEL-LABEL-指令" class="headerlink" title="LABEL (LABEL 指令)"></a>LABEL (LABEL 指令)</h3><p>可以为镜像添加标签来帮助通过项目组织镜像, 记录授权信息, 帮助自动化等等</p>
<p>可以添加多个 LABEL</p>
<p>在 Docker 1.10 前, 推荐只使用一个 LABEL, 这是为了防止每个 LABEL 生成一个额外的层</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor1=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor2=ZENITH\ Incorporated</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels on one line</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="RUN-RUN-指令"><a href="#RUN-RUN-指令" class="headerlink" title="RUN (RUN 指令)"></a>RUN (RUN 指令)</h3><p>将长或复杂的 <code>RUN</code> 语句拆分为用反斜杠 <code>\</code> 分隔的多行, 以使您的 <code>Dockerfile</code> 更具可读性, 可理解性和可维护性</p>
<h4 id="apt-get"><a href="#apt-get" class="headerlink" title="apt-get"></a>apt-get</h4><p><code>RUN</code> 最常见的用例可能是 <code>apt-get</code> 的应用程序. 因为用它来安装软件包，所以 <code>RUN apt-get</code> 命令有几个需要注意的问题</p>
<p>Example - 总是在同一个 <code>RUN</code> 语句中将 <code>RUN apt-get update</code> 和 <code>apt-get install</code> 结合在一起:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get upadte &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p><code>rm -rf /var/lib/apt/lists/*</code> 命令用来清理 apt 缓存, 减少镜像大小, 因为 apt 的缓存没有保存在一个层里面了</p>
<h4 id="Using-pipes-使用管道"><a href="#Using-pipes-使用管道" class="headerlink" title="Using pipes (使用管道)"></a>Using pipes (使用管道)</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -O - https://some.site | <span class="built_in">wc</span> -l &gt; /number</span></span><br></pre></td></tr></table></figure>

<p>Docker 使用 <code>/bin/sh -c</code> 翻译器来执行这些命令, 这个翻译器只会评估管道中最后一个操作的退出码来判断是否成功</p>
<p>例如上面的例子, 如果 <code>wc</code> 命令成功则认为构建阶段成功并生成一个新的镜像, 即使 <code>wget</code> 命令失败了</p>
<p>如果你希望命令因为管道中的任意阶段的错误而失败, 前置 <code>set -o pipefail &amp;&amp;</code> 来确保意外错误不会导致构建无意中成功:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -o pipefail &amp;&amp; wget -O - https://some.site | <span class="built_in">wc</span> -l /number</span></span><br></pre></td></tr></table></figure>

<p>注意: 不是所有 shell 都支持 <code>-o pipefail</code> 选项</p>
<p>考虑使用 <code>RUN</code> 的 <code>exec</code> 形式来明确指定一个支持 <code>pipefial</code> 选项的 shell:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l /number&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="CMD-CMD-指令"><a href="#CMD-CMD-指令" class="headerlink" title="CMD (CMD 指令)"></a>CMD (CMD 指令)</h3><p><code>CMD</code> 指令应该用于使用任何参数运行镜像中包含的软件</p>
<p><code>CMD</code> 应该总是使用 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式</p>
<p>因此如果镜像是用作一个服务, 例如 Apache 和 Rails, 可以像这样 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code></p>
<p>事实上，这种形式的指令推荐用于任何基于服务的镜像</p>
<p>在大多情况下, <code>CMD</code> 应该给定一个交互式 shell, 例如 bash, python 或 perl</p>
<p>例如, <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]</code>, <code>CMD [&quot;python&quot;]</code>, <code>CMD [&quot;php&quot;, &quot;-a&quot;]</code></p>
<p>使用这种形式意味着当你执行 <code>docker run -ti python</code> 时, 你会进入到一个可使用的 shell 中</p>
<p><code>CMD</code> 应该极少地以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的方式与 <code>ENTRYPOINT</code> 一起使用, 除非你和你的预期用户已经非常熟悉 <code>ENTRYPOINT</code> 的工作方式</p>
<h3 id="EXPOSE-EXPOSE-指令"><a href="#EXPOSE-EXPOSE-指令" class="headerlink" title="EXPOSE (EXPOSE 指令)"></a>EXPOSE (EXPOSE 指令)</h3><p><code>EXPOST</code> 指令指明容器在哪个端口上监听连接</p>
<p>因此, 应该为你的应用程序使用通用的传统的端口</p>
<p>例如, Apache web server 应该使用 <code>EXPOSE 80</code>, MongoDB 应该使用 <code>EXPOSE 27017</code></p>
<p>对于外部访问, 你的用户可以使用带有一个标志的 <code>docker run</code> 命令, 这个标志指示了怎样映射指定端口到他们选择的端口上</p>
<p>对于容器链接, Docker 为 从 接收容器 到 源容器的路径 提供了环境变量 (例如, <code>MYSQL_PORT_3306_TCP</code>)</p>
<h3 id="ENV-ENV-指令"><a href="#ENV-ENV-指令" class="headerlink" title="ENV (ENV 指令)"></a>ENV (ENV 指令)</h3><p>为了让新的软件更易于使用, 你可以使用 <code>ENV</code> 来为你的容器中安装的软件更新 <code>PATH</code> 环境变量. 例如, <code>ENV PATH=/usr/local/nginx/bin:$PATH</code> 确保 <code>CMD [&quot;nginx&quot;]</code> 正常工作</p>
<p><code>ENV</code> 指令还可用于提供 特定于你想要容器化的服务 所需的 环境变量, 例如 Postgres 的 <code>PGDATA</code></p>
<p>最后, <code>ENV</code> 还可以用来设置常用的版本号, 使版本变化更容易维护:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR=<span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION=<span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL https://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgres &amp;&amp; ...</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=/usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>类似于在程序中的常量 (与硬编码值相反), 这种方法允许你改变单个 <code>ENV</code> 指令来自动神奇地提升容器中软件的版本</p>
<p>每个 <code>ENV</code> 行创建一个新的中间层, 就像 <code>RUN</code> 命令. 这意味着即使你在后面的的层中取消 (unset) 环境变量, 这个环境变量还会持久化在这个层中且它的值可以被转存 (dumped). 你可以通过创建一个 Dockerfile 并构建它来测试一下:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line">FRO alpine</span><br><span class="line"><span class="keyword">ENV</span> ADMIN_USER=<span class="string">&quot;mark&quot;</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$ADMIN_USER</span> &gt; ./mark</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">unset</span> ADMIN_USER</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --<span class="built_in">rm</span> <span class="built_in">test</span> sh -c <span class="string">&#x27;echo $ADMIN_USER&#x27;</span></span><br><span class="line"></span><br><span class="line">mark</span><br></pre></td></tr></table></figure>

<p>为了避免这样并真正地 unset 环境变量, 使用带有 shell 命令的 <code>RUN</code> 命令来在单个层中 set, use, unset 这个变量</p>
<p>可以使用 <code>;</code> 或 <code>&amp;&amp;</code> 来分隔你的命令. 如果使用 <code>&amp;&amp;</code>, 且任何一个命令失败, <code>docker build</code> 也会跟着失败. 这通常是个好主意</p>
<p>使用 <code>\</code> 作为行持续字符来为 Linux Dockerfiles 提高可读性</p>
<p>你也可以将所有的命令保存到一个 shell 脚本中, 然后使用 <code>RUN</code> 命令来运行这个 shell 脚本:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">export</span> ADMIN_USER=<span class="string">&quot;mark&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="variable">$ADMIN_USER</span> &gt; ./mark \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">unset</span> ADMIN_USER</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> sh</span></span><br></pre></td></tr></table></figure>

<h3 id="ADD-or-COPY-ADD-或-COPY-指令"><a href="#ADD-or-COPY-ADD-或-COPY-指令" class="headerlink" title="ADD or COPY (ADD 或 COPY 指令)"></a>ADD or COPY (ADD 或 COPY 指令)</h3><p>虽然 <code>ADD</code> 和 <code>COPY</code> 功能相似, 总的来说, 推荐使用 <code>COPY</code></p>
<p>这是因为 <code>COPY</code> 比 <code>ADD</code> 更加透明</p>
<p><code>COPY</code> <strong>只支持基础的将本地文件复制到容器中</strong></p>
<p>但是 <code>ADD</code> 还有一些不是很明显的额外的功能 (像是仅限本地的 tar 文件解压缩和远程 URL 获取)</p>
<p>因此, <code>ADD</code> 的最佳用途是将本地 tar 文件自动提取到镜像中, 例如: <code>ADD rootfs.tar.xz /</code></p>
<p>如果你有多个 <code>Dockerfile</code> 步骤使用了来自你的上下文中的不同文件, 单独 <code>COPY</code> 它们, 而不是一次性全部 <code>COPY</code>. 这确保了每个步骤的构建缓存仅在特定的需要的文件发生改变时才失效 (强制重新运行该步骤)</p>
<p>Example:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Requirements.txt /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br></pre></td></tr></table></figure>

<p>与将 <code>COPY . /tmp/</code> 放在前面相比, <code>RUN</code> 步骤导致的缓存失效更少. 因为 <code>COPY . /tmp/</code> 将更多的文件进行了复制</p>
<p>因为镜像大小很重要, 所以强烈建议不要使用 <code>ADD</code> 从远程 URLs 获取包; 应该改成使用 <code>curl</code> 或 <code>wget</code></p>
<p>这样, 可以在提取文件之后删除不再需要的文件且不必在镜像中添加另外一层</p>
<p>Example - 避免这样做:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> https://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>相反地, 要这样做:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL https://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p>对于其他的不需要使用 <code>ADD</code> 的自动抽取功能的项目 (文件, 目录), 应该总是使用 <code>COPY</code></p>
<h3 id="ENTRYPOINT-ENTRYPOINT-指令"><a href="#ENTRYPOINT-ENTRYPOINT-指令" class="headerlink" title="ENTRYPOINT (ENTRYPOINT 指令)"></a>ENTRYPOINT (ENTRYPOINT 指令)</h3><p><code>ENTRYPOINT</code> 的最佳用途是设置镜像的主命令, 使得镜像 像 该命令一样 运行 (然后使用 <code>CMD</code> 作为默认标志)</p>
<p>Example - 使用 <code>s3cmd</code> 命令行工具:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>现在镜像可以像这样运行来展示命令帮助信息: <code>$ docker run s3cmd</code></p>
<p>或者使用正确的参数来执行命令: <code>$ docker run s3cmd ls s3://mybucket</code></p>
<p>如同上面的命令所示的, 这非常有用, 因为镜像的名称可以兼作对二进制文件的引用</p>
<p><code>ENTRYPOINT</code> 指令也可以与帮助脚本结合使用, 允许它以与上述命令类似的方式运行, 即使在启动工具时可能需要多个步骤</p>
<p>例如, <a class="link"   target="_blank" rel="noopener" href="https://hub.docker.com/_/postgres/" >Postgres 官方镜像<i class="fas fa-external-link-alt"></i></a> 使用如下脚本作为它的 <code>ENTRYPOINT</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> = <span class="string">&#x27;postgres&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">chown</span> -R postgres <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="subst">$(ls -A <span class="string">&quot;<span class="variable">$PGDATA</span>&quot;</span>)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个帮助脚本被复制到容器中, 且在容器启动时通过 <code>ENTRYPOINT</code> 运行:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;postgres&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>这个脚本允许用户以多种方式和 Postgres 进行交互</p>
<p>简单地启动 Postgres: <code>$ docker run postgres</code></p>
<p>运行 Postgres 并传递参数给 server: <code>$ docker run postgres postgres --help</code></p>
<p>最后它还可以用来启动一个完全不同的工具, 例如: <code>$ docker run --rm -it postgres bash</code></p>
<h3 id="VOLUME-VOLUME-指令"><a href="#VOLUME-VOLUME-指令" class="headerlink" title="VOLUME (VOLUME 指令)"></a>VOLUME (VOLUME 指令)</h3><p><code>VOLUME</code> 指令应该用来公开任何数据库存储区域, 配置存储或者由 docker 容器创建的文件&#x2F;文件夹</p>
<p>强烈建议将 <code>VOLUME</code> 用于镜像的任何 可变的 和&#x2F;或 用户可维护的 部分</p>
<h3 id="USER-USER-指令"><a href="#USER-USER-指令" class="headerlink" title="USER (USER 指令)"></a>USER (USER 指令)</h3><p>如果一个服务可以不需要权限来运行, 使用 <code>USER</code> 改成一个非 root 用户</p>
<p>通过在 <code>Dockerfile</code> 中创建用户和用户组来开始, 使用类似这样的指令: <code>RUN groupadd -r postgres &amp;&amp; useradd --no-log-init -r -g postgres postgre</code></p>
<p>注意, 考虑明确的 UID&#x2F;GID: 镜像中的用户和用户组被分配了一个不确定的 UID&#x2F;GID, 因为无论镜像如何重建, 都会分配 “下一个” UID&#x2F;GID. 所以, 如果它很关键, 应该分配一个显示的 UID&#x2F;GID</p>
<p>由于 Go archive&#x2F;tar 包的处理稀疏文件的一个未解决的 bug, 尝试在 Docker 容器中创建具有非常大 UID 的用户可能会导致磁盘空间耗尽, 因为容器层中的 <code>/var/log/faillog</code> 已填充 NULL (\0) 字符</p>
<p>一种解决方法是将 <code>--no-log-init</code> 标志传递给 useradd</p>
<p>Debian&#x2F;Ubuntu <code>adduser</code> 包装器不支持这个标志</p>
<p>避免安装或使用 <code>sudo</code>, 因为它具有不可预测的 TTY 和可能导致问题的信号转发行为. 如果你真的需要类似于 <code>sudo</code> 的功能, 例如将守护进程初始化为 <code>root</code> 当以非 <code>root</code> 的身份运行, 请考虑使用 <code>gosu</code></p>
<p>最后, 为了减少层和复杂性, 避免频繁地来回切换用户</p>
<h3 id="WORKDIR-WORKDIR-指令"><a href="#WORKDIR-WORKDIR-指令" class="headerlink" title="WORKDIR (WORKDIR 指令)"></a>WORKDIR (WORKDIR 指令)</h3><p>为了清晰性和可靠性, 你应该始终为你的 <code>WORKDIR</code> 使用绝对路径</p>
<p>此外, 你应该使用 <code>WORKDIR</code> 而不是像 <code>RUN cd ... &amp;&amp; do-something</code> 之类的指令, 这些指令难以阅读, 故障排除和维护</p>
<h3 id="ONBUILD-ONBUILD-指令"><a href="#ONBUILD-ONBUILD-指令" class="headerlink" title="ONBUILD (ONBUILD 指令)"></a>ONBUILD (ONBUILD 指令)</h3><p>当前 <code>Dockerfile</code> 构建结束后, 将执行 <code>ONBUILD</code> 命令</p>
<p><code>ONBUILD</code> 在 从当前镜像派生的 任何子镜像 中运行</p>
<p>将 <code>ONBUILD</code> 命令看作 父<code>Dockerfile</code> 传递给 子<code>Dockerfile</code> 的指令</p>
<p>Docker 构建在 子<code>Dockerfile</code> 中的所有命令之前执行 <code>ONBUILD</code> 命令</p>
<p><code>ONBUILD</code> 对于镜像很有用, 这个镜像 <code>FROM</code> 一个给定镜像中构建. 例如, 你可以将 <code>ONBUILD</code> 用于一个语言栈镜像, 这个镜像在 <code>Dockerfile</code> 中构建以该语言编写的任意用户软件, 正如你在 <a target="_blank" rel="noopener" href="https://github.com/docker-library/ruby/blob/c43fef8a60cea31eb9e7d960a076d633cb62ba8d/2.4/jessie/onbuild/Dockerfile">Ruby 的 <code>ONBUILD</code> 变体</a> 中看到的</p>
<p>使用 <code>ONBUILD</code> 构建的镜像要有一个单独的标签, 例如: <code>ruby:1.9-onbuild</code> 或 <code>ruby:2.0-onbuild</code></p>
<p>将 <code>ADD</code> 或 <code>COPY</code> 添加到 <code>ONBUILD</code> 时要小心. 如果新构建的上下文缺少要添加的资源, 则 <code>ONBUILD</code> 镜像会灾难性地失败. 如上所述, 添加一个单独的标签有助于让 <code>Dockerfile</code> 作者做出选择来缓解这种情况</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   target="_blank" rel="noopener" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#leverage-build-cache" >Dockerfile best practices<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：Best practices for writing Dockerfiles</li>
        <li>本文作者：林威羽</li>
        <li>创建时间：2022-05-23 09:58:35</li>
        <li>
            本文链接：https://linweiyu21.github.io/docker/best-practices-for-writing-dockerfiles/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/Docker/">#Docker</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/Notes/">#Notes</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/docker/compose/get-started-with-docker-compose/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Get started with Docker Compose</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/docker/dockerfile-reference/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Dockerfile reference</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script data-pjax
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script data-pjax>
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: '8xWQ0WFbKUNN4h8ixIO12etk-gzGzoHsz',
                    appKey: '7cLjTvkIsF6aIuIVSd0um89m',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: '请开始你的表演',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = '林威羽';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('true') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">林威羽</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#General-guidelines-and-recommendations-%E4%B8%80%E8%88%AC%E5%87%86%E5%88%99%E5%92%8C%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">General guidelines and recommendations (一般准则和建议)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Create-ephemeral-containers-%E5%88%9B%E5%BB%BA%E4%B8%B4%E6%97%B6%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">Create ephemeral containers (创建临时容器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Understand-build-context-%E7%90%86%E8%A7%A3%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">1.2.</span> <span class="nav-text">Understand build context (理解构建上下文)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pipe-Dockerfile-through-stdin-%E9%80%9A%E8%BF%87-stdin-%E7%AE%A1%E9%81%93%E5%8C%96-Dockerfile"><span class="nav-number">1.3.</span> <span class="nav-text">Pipe Dockerfile through stdin (通过 stdin 管道化 Dockerfile)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-an-image-using-a-Dockerfile-from-stdin-without-sending-build-context-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-Dockerfile-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-%E4%B8%8D%E5%8F%91%E9%80%81%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="nav-number">1.3.1.</span> <span class="nav-text">Build an image using a Dockerfile from stdin, without sending build context (使用来自 stdin 的 Dockerfile 构建镜像, 不发送构建上下文)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-from-a-local-build-context-using-a-Dockerfile-from-stdin-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-Dockerfile"><span class="nav-number">1.3.2.</span> <span class="nav-text">Build from a local build context, using a Dockerfile from stdin (从本地构建上下文进行构建, 使用来自 stdin 的 Dockerfile)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Build-from-a-remote-build-context-using-a-Dockerfile-from-stdin-%E4%BD%BF%E7%94%A8%E6%9D%A5%E8%87%AA-stdin-%E7%9A%84-Dockerfile-%E4%BB%8E%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%E8%BF%9B%E8%A1%8C%E6%9E%84%E5%BB%BA"><span class="nav-number">1.3.3.</span> <span class="nav-text">Build from a remote build context, using a Dockerfile from stdin (使用来自 stdin 的 Dockerfile, 从一个远程构建上下文进行构建)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exclude-with-dockerignore-%E4%BD%BF%E7%94%A8-dockerignore-%E8%BF%9B%E8%A1%8C%E6%8E%92%E9%99%A4"><span class="nav-number">1.4.</span> <span class="nav-text">Exclude with .dockerignore (使用 .dockerignore 进行排除)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Use-multi-stage-builds-%E4%BD%BF%E7%94%A8%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="nav-number">1.5.</span> <span class="nav-text">Use multi-stage builds (使用多阶段构建)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Don%E2%80%99t-install-unnecessary-packages-%E4%B8%8D%E8%A6%81%E5%AE%89%E8%A3%85%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%8C%85"><span class="nav-number">1.6.</span> <span class="nav-text">Don’t install unnecessary packages (不要安装不必要的包)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decouple-applications-%E8%A7%A3%E8%80%A6%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.7.</span> <span class="nav-text">Decouple applications (解耦应用程序)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minimize-the-number-of-layers-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%B1%82%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.8.</span> <span class="nav-text">Minimize the number of layers (最小化层的数量)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sort-multi-line-arguments-%E6%8E%92%E5%BA%8F%E5%A4%9A%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">Sort multi-line arguments (排序多行参数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leverage-build-cache-%E5%88%A9%E7%94%A8%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98"><span class="nav-number">1.10.</span> <span class="nav-text">Leverage build cache (利用构建缓存)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dockerfile-instructions-Dockerfile-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">Dockerfile instructions (Dockerfile 指令)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FROM-FROM-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.1.</span> <span class="nav-text">FROM (FROM 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LABEL-LABEL-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.2.</span> <span class="nav-text">LABEL (LABEL 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RUN-RUN-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.3.</span> <span class="nav-text">RUN (RUN 指令)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#apt-get"><span class="nav-number">2.3.1.</span> <span class="nav-text">apt-get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-pipes-%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93"><span class="nav-number">2.3.2.</span> <span class="nav-text">Using pipes (使用管道)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMD-CMD-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.4.</span> <span class="nav-text">CMD (CMD 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPOSE-EXPOSE-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.5.</span> <span class="nav-text">EXPOSE (EXPOSE 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENV-ENV-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.6.</span> <span class="nav-text">ENV (ENV 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ADD-or-COPY-ADD-%E6%88%96-COPY-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.7.</span> <span class="nav-text">ADD or COPY (ADD 或 COPY 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ENTRYPOINT-ENTRYPOINT-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.8.</span> <span class="nav-text">ENTRYPOINT (ENTRYPOINT 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VOLUME-VOLUME-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.9.</span> <span class="nav-text">VOLUME (VOLUME 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#USER-USER-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.10.</span> <span class="nav-text">USER (USER 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WORKDIR-WORKDIR-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.11.</span> <span class="nav-text">WORKDIR (WORKDIR 指令)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ONBUILD-ONBUILD-%E6%8C%87%E4%BB%A4"><span class="nav-number">2.12.</span> <span class="nav-text">ONBUILD (ONBUILD 指令)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
